const assert = require('assert');

// third-party dependencies
const should = require('should');
const jwt = require('jsonwebtoken');

// lib
const hToken = require('../../lib');

// auxiliary
const aux = require('../auxiliary');

const SECRET = 'test-secret';

describe('hToken#verify', function () {

  var ASSETS;

  beforeEach(function (done) {
    aux.setup()
      .then((assets) => {
        ASSETS = assets;

        ASSETS.ht = hToken({
          mongooseConnection: ASSETS.mongooseConnection,
          tokenModelName: 'TestToken',
          secret: SECRET,
          issuer: 'test-issuer',
          // 1000 seconds
          defaultTokenExpiry: 1000,
        });

        done();
      });
  });

  afterEach(function (done) {
    aux.teardown().then(done);
  });

  it('should require token to be a string', function () {
    assert.throws(function () {
      ASSETS.ht.verify(false);
    }, hToken.errors.InvalidTokenError);
  });

  it('should reject forged tokens', function (done) {

    var ht = ASSETS.ht;

    var forgedToken = jwt.sign({ foo: 'bar' }, 'FORGED-SECRET');

    aux.ensureBluebird(ht.verify(forgedToken))
      .then((decoded) => {
        // should not happen!
        done(new Error('forgedToken was decoded'));
      })
      .catch((err) => {
        err.should.be.instanceof(hToken.errors.InvalidTokenError);
        err.reason.should.equal('InvalidSignature');
        done();
      });

  });

  it('should verify a JWT token', function (done) {
    var ht = ASSETS.ht;

    var payload = {
      someData: 'someValue'
    };

    var options = {
      subject: 'someone'
    };

    ht.generate(payload, options)
      .then((token) => {
        token.should.be.a.String();

        return aux.ensureBluebird(ht.verify(token))

      })
      .then((decoded) => {
        decoded.someData.should.equal(payload.someData);

        // sub should be taken from options
        decoded.sub.should.equal(options.subject);

        done();
      })
      .catch((err) => {
        done(err);
      });
  });

  it('should refuse to verify a JWT token generated by another issuer', function (done) {
    var ht = ASSETS.ht;

    var ht2 = hToken({
      mongooseConnection: ASSETS.mongooseConnection,
      tokenModelName: 'AnotherTestToken',
      secret: SECRET,
      issuer: 'another-test-issuer',
      // 1000 seconds
      defaultTokenExpiry: 1000,
    });

    var payload = {
      someData: 'someValue'
    };

    var options = {
      subject: 'someone'
    };

    ht2.generate(payload, options)
      .then((token) => {
        token.should.be.a.String();

        return aux.ensureBluebird(
          ht.verify(token)
        );

      })
      .then(() => {
        done(new Error('error expected'));
      }, (err) => {
        err.should.be.instanceof(hToken.errors.InvalidTokenError);
        err.name.should.equal('InvalidTokenError');
        err.reason.should.equal('InvalidIssuer');

        done();
      })
      .catch(done);
  });

  it('should reject malformed tokens', function (done) {

    var ht = ASSETS.ht;

    // remove the starting 50 characters
    var malformedToken = jwt.sign({ foo: 'bar' }, SECRET);
    malformedToken = malformedToken.substr(50, malformedToken.length);

    aux.ensureBluebird(ht.verify(malformedToken))
      .then((decoded) => {
        // should not happen!
        done(new Error('malformedToken was decoded'));
      })
      .catch((err) => {
        err.should.be.instanceof(hToken.errors.InvalidTokenError);
        err.reason.should.equal('MalformedJWT');
        done();
      });

  });

  it('should reject expired tokens', function (done) {
    this.timeout(5000);

    var ht = ASSETS.ht;

    // remove the starting 50 characters
    var expiredToken = jwt.sign({ foo: 'bar' }, SECRET, {
      expiresIn: '1s',
    });

    setTimeout(function () {

      ht.verify(expiredToken).then((decoded) => {
        done(new Error('expected error'));
      })
      .catch((err) => {
        err.should.be.instanceof(hToken.errors.InvalidTokenError);
        err.reason.should.equal('TokenExpired');
        done();
      });

    }, 2000);
  });
});